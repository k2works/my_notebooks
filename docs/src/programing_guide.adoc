:toc: left
:toclevels: 5
:sectnums:

= プログラミングガイド

== 動機
=== プログラミングは問題解決

==== プログラミングパラダイム

===== SP(Structured Programming)
[quote, Clean Architecture]

---

The first paradigm to be adopted(but not the first to be invented) was structured programming, which was discovered by Edsger Wybe Dijkstra in 1968. Dijkstra showed that the use of unrestrained jumps(goto statements) is harmful to program structure. As we'll see in the chapters that follow, he replaced those jumps with the more familiar if/then/eles and do/while/until constructs.

We can summarize the structured programming paradigm as follows:

Structured programming imposes discipline on direct transfer of control.

---

===== OOP(Object-Oriented Programming)

[quote, Clean Architecture]

---

The second paradigm to be adopted was actually discovered two years earlier, in 1966, by Ole Johan Dahl and Kristen Nygaard. These two programmers noticed that the function call stack frame in the ALGOL language could be moved to a heap, thereby allowing local variables declared by a function to exist long after the function returned. The function become a constructor for a class, the local variables become instance variables, and the nested functions become methods. This led inevitably to the discovery of polymorphism through the disciplined use of function pointers.

We can summarize the object-oriented programming paradigm as follows:

Object-oriented programming imposes discipline on indirect transfer of control.

---

===== FP(Fcuntional Programming)
[quote, Clean Architecture]

---

The third paradigm, which has only recently begun to be adopted, was the first to be invented. Indeed, its invention predates computer programming itself. Functional programming is the direct result of the work of Alonzo Church, who in 1936 invented λ-calculus while pursuing the same mathematical problem that was motivating Alan Turing at the same time. His λ-calculus is the foundation of the LISP language, invented in 1958 by John McCarthy. A foundational notion of λ-calculus is immutability---that is, the notion that the values of symbols do not change. This effectively means that is, the notion that that the values of symbols do not change. This effectively means that a functional language has no assignment statement. Most functional languages do, in fact, have some means to alter the value of a variable, but only under very strict discipline.

We can summarize the functional programming paradigm as follows:

Functional programming imposes discipline upon assignment.

---

==== プログラミングアプローチ

===== POA(ProcessOrientedApproach)

「業務処理プロセス」に着目するアプローチ手法。
POA は、業務内容を中心に設計されるためシステム設計が業務内容に強く依存する。そのため、業務内容が変更になったときにはシステムの大幅な変更が必要となりコスト面の負担が大きくなる。また、各部署の業務内容に応じて独立したシステムになることが多く、他のシステムとのデータ連携が複雑になるという問題がある。

===== DOA(DataOrientedApproach)

「どんなデータを必要とするか」に着目するアプローチ手法。
DOA では、データを業務プロセスとは切り離して先に ER モデルを用いて分析・設計する。業務のモデル化を行う際にデータが最も安定した情報資源であり、かつ共通資源であることを利用するため、業務変更によるシステムへの影響度が少なくなる。また、事象応答分析も行い、外部からの事象とその応答のタイミング的、時間的な関係を抽出し、制御の流れも図式化して分析する。

===== OOA(ObjectOrientedApproach)

「データとそれを操作する手続き（メソッド）の両方、すなわちオブジェクト」に着目するアプローチ手法。
DOA の概念をさらに進めたアプローチ。オブジェクトとは、データ（属性）とそのデータに対する手続き（メソッド）を１つにまとめたものを指す。

===== SOA(ServiceOrientedApproach)

個々のシステムをサービスという概念で捉えてシステムを構築する「やり方」（共通のメッセージ交換インタフェースに対応）。
サービスとは、業務上の１つの処理に相当するソフトウェアの機能。SOA を実現するために必要となる技術基盤は、ほとんどの場合 Web サービスとなる。

=== プログラミングは技術
==== Principal（原則）
==== Pattern（パターン）
==== Practise（実践）

=== プログラミングは楽しい

- [ ] 自分の思い通りのモノを作る楽しさ
- [ ] 人の役に立つモノを作る楽しさ
- [ ] ピタゴラスイッチを作る楽しさ
- [ ] 新しいものを学ぶ楽しさ
- [ ] もっとも柔軟な媒体でものを作る楽しさ

== 原則
=== 基本定理<<UNIXP>>

1. スモール・イズ・ビューティフル
1. 一つのプログラムには一つのことをうまくやらせる
1. できるだけ早く試作する
1. 効率より移植性
1. 数値データは ASCII フラットファイルに保存する
1. ソフトウェアの梃子を有効に活用する
1. シェルスクリプトを使うことで梃子の効果と移植性を高める
1. 過度の対話的インタフェースを避ける
1. すべてのプログラムをフィルタにする

=== アジャイル宣言の背後にある原則

1. 顧客満足を最優先し、価値のあるソフトウェアを早く継続的に提供します。
1. 要求の変更はたとえ開発の後期であっても歓迎します。変化を味方につけることによって、お客様の競争力を引き上げます。
1. 動くソフトウェアを、2-3 週間から 2-3 ヶ月というできるだけ短い時間間隔でリリースします。
1. ビジネス側の人と開発者は、プロジェクトを通して日々一緒に働かなければなりません。
1. 意欲に満ちた人々を集めてプロジェクトを構成します。環境と支援を与え仕事が無事終わるまで彼らを信頼します。
1. 情報を伝えるもっとも効率的で効果的な方法はフェイス・トゥ・フェイスで話をすることです。
1. 動くソフトウェアこそが進捗の最も重要な尺度です。
1. アジャイル･プロセスは持続可能な開発を促進します。一定のペースを継続的に維持できるようにしなければなりません。
1. 技術的卓越性と優れた設計に対する不断の注意が機敏さを高めます。
1. シンプルさ（ムダなく作れる量を最大限にすること）が本質です。
1. 最良のアーキテクチャ・要求・設計は、自己組織的なチームから生み出されます。
1. チームがもっと効率を高めることができるかを定期的に振り返り、それに基づいて自分たちのやり方を最適に調整します。

=== 設計原則<<PPP02>>

- 単一責任の原則(SRP)
- オープン・クローズドの原則(OCP)
- リスコフの置換原則(LSP)
- 依存関係逆転の原則(DIP)
- インタフェース分離の原則(ISP)

=== パッケージ設計の原則<<PPP02>>

- 再利用・リリース等価の原則(REP: Reuse-Release Equivalency)
- 全再利用の原則(CRP: Common Reuse Principle)
- 閉鎖性共通の原則(CCP: Common Closure Principle)
- 非循環依存関係の原則(ADP: Acyclic Dependencies Principle)
- 安定依存の原則(SDP: Stable Dependencies Principle)
- 安定度・抽象度等価の原則(SAP: Stable Abstractions Principle)

=== プログラミング原則

- KISS (Keep It Simple, Stupid. or Keep It Short and Simple)
- DRY (Don't Repeat Yourself.)
- YAGNI (You Aren't Going to Need It.)
- PIE (Program Intently and Expressively.)
- SLAP(Single Level of Abstraction Principle.)
- 名前重要 (Naming is important.)
- https://martinfowler.com/bliki/MonolithFirst.html[MonolithFirst]
- Immutable object
- Separating concerns

=== システム設計の原則<<PoSA>>

- 小さくまとめてわかりやすくする
- 場合分けのロジックを整理する
- 業務ロジックをわかりやすく整理する
- ドメインモデルの考え方で設計する
- アプリケーション機能を組み立てる
- データベースの設計とドメインオブジェクト
- 画面とドメインオブジェクトの設計を連動させる
- アプリケーション間の連携
- オブジェクト指向の開発プロセス
- オブジェクト指向設計の学び方と教え方

=== プログラミングの理論<<IP>>

- 価値
  ** コミュニケーション
  ** シンプル
  ** 柔軟性
- 原則
  ** 結果の局所化
  ** 繰返しの最小化
  ** ロジックとデータの一体化
  ** 対称性
  ** 宣言型の表現
  ** 変更頻度

=== 達人プログラマー Tips

1. 自らの技術に関心を持つこと
1. あなたの仕事について考えること!
1. いい加減な言い訳よりも対策を用意すること
1. 割れた窓を放置しておかないこと
1. 変化の触媒たれ
1. 大きな構想を忘れないようにすること
1. 品質要求を明確にすること
1. あなたの知識ポートフォリオに対して定期的な投資を行うこと
1. 見聞きしたものごとを批判的な目で分析すること
1. 伝えることがらと、伝える方法は車の車輪だと考えること
1. DRY --- Don't Repeat Yourself (繰り返しを避けること)
1. 再利用しやすいようにしておくこと
1. 関係ないもの同士の影響を排除すること
1. 最終決定などというものは存在しない
1. 目標を見つけるには曳光弾を使うこと
1. プロトタイプの真の目的は学びにある
1. 問題領域に近いところでプログラミングを行うこと
1. 後でびっくりしないために、見積もりを行うこと
1. 規律に従ってスケジュールを繰り返し、精度を向上させていくこと
1. 知識はプレインテキストに保存すること
1. コマンドシェルの力を使うこと
1. 一つのエディタを熟知すること
1. 常にソースコード管理システムを使用すること
1. 非難するのではなく、問題を修復すること
1. パニックに陥らないこと
1. "select"はおかしくない
1. 仮定せずに、証明すること
1. テキスト操作言語を学ぶこと
1. コードを生成するコードを作成すること
1. ウィザードの生成コードが理解できないのであれば、ウィザードを使わないこと
1. 要求は拾い集めるものではなく、掘り起こすものである
1. ユーザーの視点に立つには、ユーザーと働くこと
1. 抽象は詳細よりもの息が長いものである
1. プロジェクトの用語集を作ること
1. 枠にとらわれずに考えるのではなく、枠を見つけ出すこと
1. 心の声に耳を傾け、準備ができてから開始すること
1. 解説しないほうが良い場合もある
1. 形式的方法論の奴隷になってはいけない
1. 高価なツールが良い設計を生み出すとは限らない
1. 職務権限ではなく、機能によってチームを編成すること
1. 手作業は危険である
1. 早目にテスト、何度もテスト、自動でテスト
1. テストがすべて終るまでコーディングは終わらない
1. テストのテストをするには破壊工作を試みる
1. コードのカバレージではなく、状態のカバレージをテストすること
1. 複数のバグを一度に見つけること
1. 日本語をもう一つのプログラミング言語として扱うこと
1. ドキュメントは付け足すものではなく、組み込むものである
1. ユーザーの期待を少しだけ上回ること
1. あなたの作品に署名すること

== パターン

=== エンタープライズアプリケーションアーキテクチャパターン<<PoEAA>>

==== ドメインロジックパターン

- トランザクションスクリプト
- ドメインモデル
- テーブルモジュール
- サービスレイヤ

==== データソースのアーキテクチャに関するパターン

- テーブルゲートウェイ
- 行データゲートウェイ
- アクティブレコード
- データマッパー

==== オブジェクトリレーショナル振る舞いパターン

- ユニットオブワーク
- 一意マッピング
- レイジーロード

==== オブジェクトリレーショナル構造パターン

- 一意フィールド
- 外部キーマッピング
- 関連テーブルマッピング
- 依存マッピング
- 組込バリュー
- シリアライズ LOB
- シングルテーブル継承
- クラステーブル継承
- 具象テーブル継承

==== オブジェクトリレーショナルメタデータマッピングパターン

- メタデータマッピング
- クエリーオブジェクト
- リポジトリ

==== Web プレゼンテーションパターン

- モデルビューコントローラ
- ページコントローラ
- フロントコントローラ
- テンプレートビュー
- トランスフォームビュー
- ツーステップビュー
- アプリケーションコントローラ

==== 分散パターン

- リモートファサード
- データ変換オブジェクト

==== オフライン並行性パターン

- 軽オフラインロック
- 重オフラインロック
- 緩ロック
- 暗黙ロック

==== セッションステートパターン

- クライアントセッションステート
- サーバセッションステート
- データベースセッションステート

==== ベースパターン

- ゲートウェイ
- マッパー
- レイヤースーパータイプ
- セパレートインタフェース
- レジストリ
- バリューオブジェクト
- マネー
- スペシャルケース
- プラグイン
- サービススタブ
- レコードセット

=== デザインパターン<<GOF>>

==== 生成に関するパターン

- Abstract Factory 関連する一連のインスタンスを状況に応じて、適切に生成する方法を提供する。
- Builder 複合化されたインスタンスの生成過程を隠蔽する。
- Factory Method 実際に生成されるインスタンスに依存しない、インスタンスの生成方法を提供する。
- Prototype 同様のインスタンスを生成するために、原型のインスタンスを複製する。
- Singleton あるクラスについて、インスタンスが単一であることを保証する。

==== 構造に関するパターン

- Adapter 元々関連性のない 2 つのクラスを接続するクラスを作る。
- Bridge クラスなどの実装と、呼出し側の間の橋渡しをするクラスを用意し、実装を隠蔽する。
- Composite 再帰的な構造を表現する。
- Decorator あるインスタンスに対し、動的に付加機能を追加する。Filter とも呼ばれる。
- Facade 複数のサブシステムの窓口となる共通のインタフェースを提供する。
- Flyweight 多数のインスタンスを共有し、インスタンスの構築のための負荷を減らす。
- Proxy 共通のインタフェースを持つインスタンスを内包し、利用者からのアクセスを代理する。Wrapper とも呼ばれる

==== 振る舞いに関するパターン

- Chain of Responsibility イベントの送受信を行う複数のオブジェクトを鎖状につなぎ、それらの間をイベントが渡されてゆくようにする。
- Command 複数の異なる操作について、それぞれに対応するオブジェクトを用意し、オブジェクトを切り替えることで、操作の切替えを実現する。
- Interpreter 構文解析のために、文法規則を反映するクラス構造を作る。
- Iterator 複数の要素を内包するオブジェクトのすべての要素に対して、順番にアクセスする方法を提供する。反復子。
- Mediator オブジェクト間の相互作用を仲介するオブジェクトを定義し、オブジェクト間の結合度を低くする。
- Memento データ構造に対する一連の操作のそれぞれを記録しておき、以前の状態の復帰または操作の再現が行えるようにする。
- Observer (出版-購読型モデル) インスタンスの変化を他のインスタンスから監視できるようにする。Listener とも呼ばれる。
- State オブジェクトの状態を変化させることで、処理内容を変えられるようにする。
- Strategy データ構造に対して適用する一連のアルゴリズムをカプセル化し、アルゴリズムの切替えを容易にする。
- Template Method あるアルゴリズムの途中経過で必要な処理を抽象メソッドに委ね、その実装を変えることで処理が変えられるようにする。
- Visitor データ構造を保持するクラスと、それに対して処理を行うクラスを分離する。

=== 実装パターン<<IP>>
==== クラス

- クラス
- シンプルなスーパークラス名
- 修飾的なサブクラス
- 抽象インターフェース
- インターフェース
- 抽象クラス
- 別バーションのインターフェース
- バリューオブジェクト
- 特化
- サブクラス
- 実装クラス
- 内部クラス
- インスタンス固有の振る舞い
- 条件分岐
- 委譲
- プラガブルセレクタ
- 匿名内部クラス
- ライブラリクラス

==== 状態

- 状態
- アクセス
- 直接アクセス
- 間接アクセス
- 共通の状態
- 可変の状態
- 外部の状態
- 変数
- ローカル変数
- フィールド
- 引数
- コレクティングパラメータ
- オプション引数
- 可変引数
- パラメータオブジェクト
- 定数
- 役割を示す名前
- 宣言される型
- 初期化
- 早期初期化
- 遅延初期化

==== 振る舞い

- 制御フロー
- メインフロー
- メッセージ
- 選択メッセージ
- 二重ディスパッチ
- 分割（直列）メッセージ
- 反転メッセージ
- 招待メッセージ
- 説明メッセージ
- 例外フロー
- ガード条件
- 例外
- チェック例外
- 例外の伝搬

==== メソッド

- 複合メソッド
- 意図を示す名前
- メソッドの可視性
- メソッドオブジェクト
- オーバーライドメソッド
- オーバーロードメソッド
- メソッドが返す型
- メソッドのコメント
- ヘルパーメソッド
- デバッグ出力メソッド
- 変換
- 変換メソッド
- 変換コンストラクター
- 生成
- 完全なコンストラクタ
- ファクトリメソッド
- 内部ファクトリ
- コレクション用アクセッサメソッド
- 論理値設定メソッド
- クエリーメソッド
- 等価性メソッド
- getter メソッド
- setter メソッド
- 安全なコピー

==== コレクション

- メタファー
- 問題
- インターフェース
  ** 配列
  ** Iterable
  ** Collection
  ** List
  ** Set
  ** SortedSet
  ** Map
- 実装
  ** Collection
  ** List
  ** Set
  ** Map
- Collections
  ** 検索
  ** ソート
  ** 変更不可のコレクション
  ** 要素を１つだけ含むコレクション
  ** 空のコレクション
  ** コレクションの拡張

==== フレームワークへの拡張

- アプリケーションを変更させないフレームワークへの変更
- 非互換のアップグレード
- 互換性のある変更の促進
  ** ライブラリクラス
  ** オブジェクト
  ** 使用形式
  ** 抽象化
  ** 生成
  ** メソッド

=== 言語仕様パターン

==== Ruby
|===
| | |Ruby |Python |C= |3 |4 |5 |
|Ruby の基本を学ぼう | | | | | | | |
| |Ruby をより深く学ぶために| | | | | | |
| |プログラムのはじまりとおわり| | | | | | |
| |変数とは| | | | | | |
| |オブジェクトとメソッド| | | | | | |
| |演算子とは| | | | | | |
| |コメントをつける| | | | | | |
| |インデント| | | | | | |
|定数 | | | | | | | |
| |変数の種類| | | | | | |
| |疑似変数| | | | | | |
| |定数| | | | | | |
| |nil オブジェクト| | | | | | |
|数値と演算子 | | | | | | | |
| |数値オブジェクト| | | | | | |
| |算術演算子| | | | | | |
| |シフト演算子とビット演算子| | | | | | |
| |比較演算子| | | | | | |
| |Integer のよく使われるメソッド| | | | | | |
| |Float のよく使われるメソッド| | | | | | |
|文字列 | | | | | | | |
| |文字列と文字列リテラル| | | | | | |
| |文字列のよく使われるメソッド| | | | | | |
| |日本語と文字コード| | | | | | |
| |ヒアドキュメント| | | | | | |
| |正規表現| | | | | | |
| |シンボル| | | | | | |
|文字列 | | | | | | | |
| |文字列と文字列リテラル| | | | | | |
| |文字列のよく使われるメソッド| | | | | | |
| |日本語と文字コード| | | | | | |
| |ヒアドキュメント| | | | | | |
| |正規表現| | | | | | |
| |シンボル| | | | | | |
|制御構造 | | | | | | | |
| |条件分岐| | | | | | |
| |繰り返し処理| | | | | | |
|配列／レンジ／ハッシュ | | | | | | | |
| |配列オブジェクト| | | | | | |
| |配列でよく使われるメソッド| | | | | | |
| |レンジオブジェクト(Range)| | | | | | |
| |ハッシュオブジェクト(Hash)| | | | | | |
| |ハッシュでよく使われるメソッド| | | | | | |
| |配列とレンジ、ハッシュのまとめ| | | | | | |
|メソッド | | | | | | | |
| |メソッド定義| | | | | | |
| |メソッドと戻り値| | | | | | |
| |ブロック付きメソッド| | | | | | |
|メソッド | | | | | | | |
| |メソッド定義| | | | | | |
| |メソッドと戻り値| | | | | | |
| |ブロック付きメソッド| | | | | | |
|クラスの基本 | | | | | | | |
| |クラスとは| | | | | | |
| |クラスにメソッドを定義する| | | | | | |
| |再び変数について| | | | | | |
| |アクセッサメソッド| | | | | | |
| |メソッドと可視性| | | | | | |
| |クラスの継承| | | | | | |
| |別ファイルを読み込み| | | | | | |
| |クラスと抽象化| | | | | | |
|モジュール | | | | | | | |
| |モジュールとは| | | | | | |
| |モジュールを名前空間として使う| | | | | | |
| |モジュールで Mix-in を実現する| | | | | | |
| |トップレベルや名前空間と値の探索順| | | | | | |
|例外処理 || | | | | | |
|　　　　　 |例外処理とは| | | | | | |
| |例外を補足する| | | | | | |
| |例外を発生させる| | | | | | |
|組み込みライブラリ || | | | | | |
|　　　　　 |Time クラス| | | | | | |
| |File クラス| | | | | | |
| |Dir クラス| | | | | | |
|標準添付ライブラリ || | | | | | |
| |標準添付ライブラリとは| | | | | | |
| |日付クラス(Time クラスの拡張)| | | | | | |
| |CSV を扱う(CSV クラス)| | | | | | |
| |JSON を扱う(JSON クラス)| | | | | | |
| |YAML を扱う(YAML クラス)| | | | | | |
| |一時ディレクトリ／ファイルを扱う(tmpdir／tempfile)| | | | | | |
| |ファイルの操作を行う(FileUtils モジュール)| | | | | | |
| |プログラムのテスト| | | | | | |
|組み込みツール || | | | | | |
| |irb| | | | | | |
| |RDoc| | | | | | |
| |Rake| | | | | | |
| |RubyGems| | | | | | |
| |Bundler| | | | | | |
|より高度な Ruby の知識 || | | | | | |
| |マジックコメント| | | | | | |
| |%記法| | | | | | |
| |Array と Hash の一歩進んだ使い方| | | | | | |
| |メソッドの一歩進んだ使い方| | | | | | |
| |Ruby の一般的な命名規則| | | | | | |
| |環境変数を扱う| | | | | | |
| |コマンドライン引数を扱う| | | | | | |
|| | | | | | | |
|===

==== Python
|===
| | |Ruby |Python |C= |3 |4 |5 |
|プログラミングの基本 | | | | | | | |
| |基本のデータ| | | | | | |
| |変数| | | | | | |
| |演算| | | | | | |
| |文の書き方| | | | | | |
|データ構造 || | | | | | |
| |リスト(list)| | | | | | |
| |タプル(tuple)とレンジ(range)| | | | | | |
| |セット(set)| | | | | | |
| |辞書(dict)| | | | | | |
|制御構文 || | | | | | |
| |if 文| | | | | | |
| |for 文| | | | | | |
| |while 文| | | | | | |
| |リスト内包表記| | | | | | |
|関数 || | | | | | |
| |関数の利用| | | | | | |
| |関数の作成| | | | | | |
| |ラムダ式| | | | | | |
|クラス || | | | | | |
| |オブジェクト指向| | | | | | |
| |クラスの作成| | | | | | |
| |メンバのはたらき| | | | | | |
| |継承| | | | | | |
|エラーと例外処理 || | | | | | |
| |エラーメッセージ| | | | | | |
| |例外を処理する| | | | | | |
| |例外を送る| | | | | | |
|ファイル操作 || | | | | | |
| |ファイルの読み込み| | | | | | |
| |ファイルへの書き出し| | | | | | |
| |ファイルオブジェクトを利用する| | | | | | |
|モジュール || | | | | | |
| |モジュールを利用する| | | | | | |
| |モジュールの作成| | | | | | |
| |コマンドラインからの利用| | | | | | |
|標準ライブラリの活用 || | | | | | |
| |標準ライブラリ| | | | | | |
| |算術計算- math, random, statistics| | | | | | |
| |日時 - datetime| | | | | | |
| |CSV ファイル - csv| | | | | | |
| |正規表現 - re| | | | | | |
|外部パッケージの利用 || | | | | | |
| |外部パッケージのインストール| | | | | | |
| |Web 情報の取得 - Requests| | | | | | |
| |グラフ作成 - matplotlib| | | | | | |
| |画像編集 - Pillow| | | | | | |
|応用的な文法 || | | | | | |
| |非同期構文| | | | | | |
| |イテレータ・ジェネレータ| | | | | | |
| |Python の慣習 - PEP8| | | | | | |
|===
==== C#
|===
| | |Ruby |Python |C= |3 |4 |5 |
|C#の基本を学ぶ | | | | | | | |
| |プログラムの実行順序と構成| | | | | | |
| |記述方法の基本| | | | | | |
| |ステートメントとブロック| | | | | | |
| |文字の入出力| | | | | | |
| |コメント| | | | | | |
|変数と型 | | | | | | | |
| |変数の基本| | | | | | |
| |型の種類| | | | | | |
| |宣言と初期化| | | | | | |
| |変数のスコープ| | | | | | |
| |型の変換| | | | | | |
|演算子 || | | | | | |
| |演算子の基本| | | | | | |
| |代入演算子| | | | | | |
| |算術演算子| | | | | | |
| |連結演算子| | | | | | |
| |比較演算子| | | | | | |
| |論理演算子| | | | | | |
| |その他の演算子| | | | | | |
|条件分岐 || | | | | | |
| |条件分岐の基本| | | | | | |
| |if| | | | | | |
| |if - else| | | | | | |
| |if - else if| | | | | | |
| |if とブール値| | | | | | |
| |switch - case| | | | | | |
|繰り返し処理 || | | | | | |
| |繰り返し処理の基本| | | | | | |
| |for| | | | | | |
| |foreach| | | | | | |
| |while| | | | | | |
| |do - while| | | | | | |
| |流れ制御| | | | | | |
|配列とコレクション || | | | | | |
| |配列の基本| | | | | | |
| |配列の使い方| | | | | | |
| |多次元配列| | | | | | |
| |ジャグ配列| | | | | | |
| |コレクション| | | | | | |
| |主要なコレクション| | | | | | |
|メソッド || | | | | | |
| |メソッドの基本| | | | | | |
| |メソッドの作成| | | | | | |
| |引数の指定| | | | | | |
| |オーバーロード| | | | | | |
| |戻り値の指定| | | | | | |
|クラスと構造体 || | | | | | |
| |クラスの基本| | | | | | |
| |クラスの作成| | | | | | |
| |メンバー| | | | | | |
| |コンストラクターとデストラクター| | | | | | |
| |アクセス修飾子| | | | | | |
| |パーシャルクラス| | | | | | |
| |構造体| | | | | | |
|継承 || | | | | | |
| |継承の基本| | | | | | |
| |派生クラスの作成| | | | | | |
| |ポリモーフィズム| | | | | | |
| |基本クラスへのアクセス| | | | | | |
| |オーバーライド| | | | | | |
|抽象クラスとインターフェイス || | | | | | |
| |抽象クラスの基本| | | | | | |
| |抽象クラスの作成と使用| | | | | | |
| |インターフェイスの基本| | | | | | |
| |インターフェイスの作成と使用| | | | | | |
|デリゲートとイベント || | | | | | |
| |デリゲートの基本| | | | | | |
| |デリゲートオブジェクトの生成| | | | | | |
| |汎用的なデリゲート| | | | | | |
| |イベントとデリゲートの違い| | | | | | |
|ジェネリック || | | | | | |
| |ジェネリックの基本| | | | | | |
| |ジェネリックメソッドの作成| | | | | | |
| |ジェネリッククラスの作成| | | | | | |
| |ジェネリックインターフェイスの作成| | | | | | |
| |ジェネリック型の制約| | | | | | |
| |ジェネリックコレクション| | | | | | |
|LINQ || | | | | | |
| |LINQ の概要| | | | | | |
| |LINQ の基本| | | | | | |
| |クエリキーワード| | | | | | |
| |LINQ の拡張メソッド| | | | | | |
|例外処理 || | | | | | |
| |例外処理の基本| | | | | | |
| |try-catch-finally| | | | | | |
| |例外の種類と作成| | | | | | |
| |例外の再スロー| | | | | | |
|非同期処理 || | | | | | |
| |非同期処理の基本| | | | | | |
| |非同期メソッドの作成| | | | | | |
| |非同期所の実装| | | | | | |
| |非同期処理の実行順序| | | | | | |
| |非同期処理の操作| | | | | | |
| |非同期処理の例外と取消し| | | | | | |
|Windows フォームアプリケーション作成 || | | | | | |
| |Windows プログラミングの基本| | | | | | |
| |Windows フォームアプリケーションの作成準備| | | | | | |
| |コントロールの配置と設定| | | | | | |
| |イベントに対する処理の記述| | | | | | |
| |実行と動作確認| | | | | | |
|===
==== JavaScript
|===
| | |Ruby |Python |C= |JavaScript |4 |5 |
| プログラムを書く際の約束 | | | | | | | |
| | 文字の区分 | | | | | | |
| | 命令文を書く際のルール | | | | | | |
| | コメント | | | | | | |
| | 予約語と未来予約語 | | | | | | |
| | インデント | | | | | | |
| | 命名ルール | | | | | | |
| 変数 | | | | | | | |
| | 変数とは？ | | | | | | |
| | 変数の宣言 | | | | | | |
| | 変数とは | | | | | | |
| | データ型 | | | | | | |
| 演算子 | | | | | | | |
| | 演算子とは？ | | | | | | |
| | 算術演算子 | | | | | | |
| | 代入演算子 | | | | | | |
| | ビットシフト演算子 | | | | | | |
| | 比較演算子 | | | | | | |
| | 論理演算子 | | | | | | |
| | 連結演算子 | | | | | | |
| 制御文 | | | | | | | |
| | if 文 | | | | | | |
| | else 文 | | | | | | |
| | else if 文 | | | | | | |
| | switch 文 | | | | | | |
| | for 文 | | | | | | |
| | for..of 文 | | | | | | |
| | while 文 | | | | | | |
| | do..while 文 | | | | | | |
| | 処理の中断と継続 | | | | | | |
| | try..catch..finally 文 | | | | | | |
| 配列 | | | | | | | |
| | 1次元配列 | | | | | | |
| | 多次元配列 | | | | | | |
| | ジャグ配列 | | | | | | |
| | 連想配列 | | | | | | |
| | 配列要素の追加操作 | | | | | | |
| | 配列要素の削除操作 | | | | | | |
| 関数 | | | | | | | |
| | 関数 | | | | | | |
| | 変数のスコープ | | | | | | |
| | ホイスティング | | | | | | |
| | 無名関数 | | | | | | |
| | 即時関数 | | | | | | |
| | 組み込み関数 | | | | | | |
| | 関数の応用 | | | | | | |
| クラスとプロトタイプ | | | | | | | |
| | オブジェクト指向とは | | | | | | |
| | クラス | | | | | | |
| | プロパティ | | | | | | |
| | メソッド | | | | | | |
| | プロトタイプ | | | | | | |
| | 継承 | | | | | | |
| JavaScriptオブジェクト | | | | | | | |
| | オブジェクトとは | | | | | | |
| | 数値を扱うオブジェクト Number | | | | | | |
| | 配列を扱うオブジェクト Array | | | | | | |
| | 文字列を扱うオブジェクト String | | | | | | |
| | 論理値を扱うオブジェクト Boolean | | | | | | |
| | 日付・時刻を扱うオブジェクト Data | | | | | | |
| | 数値計算を扱うオブジェクト　Math | | | | | | |
| | 正規表現を扱うオブジェクト RegExp| | | | | | |
| ブラウザオブジェクト | | | | | | | |
| | ブラウザオブジェクトとは | | | | | | |
| | Window オブジェクト | | | | | | |
| | Location オブジェクト | | | | | | |
| | History オブジェクト | | | | | | |
| HTML5 と CSS| | | | | | | |
| | HTMLの書き方 | | | | | | |
| | HTMLの作成と表示 | | | | | | |
| | 主要なタグ | | | | | | |
| | 特殊なタグ | | | | | | |
| | CSSの基礎知識 | | | | | | |
| | CSSの書き方 | | | | | | |
| | セレクタとプロパティ | | | | | | |
| ドキュメントオブジェクト | | | | | | | |
| | DOMとノード | | | | | | |
| | ドキュメントの検索 | | | | | | |
| | ドキュメントの変更 | | | | | | |
| | ドキュメントの追加と削除 | | | | | | |
| イベント | | | | | | | |
| | イベントに関するキーワード | | | | | | |
| | 画面操作に関する基本的なイベントハンドラ | | | | | | |
| | 画面フォーカスに関する基本的なイベントハンドラ | | | | | | |
| | マウスイベントハンドラ | | | | | | |
| | キーイベントハンドラ | | | | | | |
| jQuery | | | | | | | |
| | jQueryとは | | | | | | |
| | jQueryの利用準備 | | | | | | |
| | JQueryの基本の書き方 | | | | | | |
| | 要素の特定 | | | | | | |
| | 内容と属性の操作 | | | | | | |
| | 要素の追加と削除 | | | | | | |
| アニメーション処理 | | | | | | | |
| | 要素を動かす(Magic) | | | | | | |
| | ページ遷移に動作を追加する(Animsition) | | | | | | |
| | スクロール時に動きを追加する(ScrollTrigger) | | | | | | |
| | タブを動かす(tabulous.js) | | | | | | |
| | 画像とコンテンツを切り替える(imagehover.css) | | | | | | |
|===

== プラクティス
=== XP

==== 主要プラクティス

===== 全員同席

===== チーム全体

===== 情報満載のワークスペース

===== いきいきとした仕事

===== ペアプログラミング

===== ストーリー

===== 週次サイクル

===== 四半期サイクル

===== ゆとり

===== １０分ビルド

===== 継続的インテグレーション

===== テストファーストプログラミング

===== インクリメンタルな設計

==== 導出プラクティス

===== 本物の顧客参加

===== インクリメンタルなデプロイ

===== チームの継続

===== チームの縮小

===== 根本原因分析

===== コードの共有

===== コードとテスト

===== 単一のコードベース

===== デイリーデプロイ

===== 交渉によるスコープ契約

===== 利用都度課金

=== テスト駆動開発
==== テスト駆動開発のパターン

===== テスト(名詞)

- 独立したテスト
- TODO リスト
- テストファースト
- アサートファースト
- テストデータ
- 明示的なデータ

===== レッドバーのパターン

- 一歩を示すテスト
- 説明的なテスト
- 学習用テスト
- 脱線は TODO リストへ
- 回帰テスト
- 休憩
- やり直す
- 安い椅子に良い椅子

===== テスティングのパターン

- 小さいテスト
- Mock Object(偽装オブジェクト)パターン
- Self Shunt(自己接続)パターン
- Long String(記録用文字列)パターン
- Crash Test Dummy(衝突実験ダミー人形)パターン
- 失敗させたままのテスト
- きれいなチェックイン

===== グリーンバーのパターン

- 仮実装を経て本実装へ
- 三角測量
- 明白な実装
- 一から多へ
- xUnit のパターン
- フィクスチャー
- 外部フィクスチャー
- テストメソッド
- 例外のテスト
- まとめてテスト

===== デザインパターン

- Command パターン
- Value Object パターン
- Null Object パターン
- Template Method パターン
- Pluggable Object パターン
- Factory Method パターン
- Imposter パターン
- Collecting Parameter パターン
- Singleton パターン

===== リファクタリング

- 差異をなくす
- 変更の分離
- データ構造の変更
- メソッドの抽出
- メソッドのインライン化
- インタフェースの抽出
- メソッドの移動
- メソッドオブジェクト
- パラメータの追加
- メソッドからコンストラクタへのパラメータの移動

==== F.I.R.S.T

1. Fast(高速)
1. Independent(独立)
1. Repeatable(再現性)
1. Self-Validating(自己検証可能)
1. Timely(適時性)

=== リファクタリング
==== リファクタリング<<Refactoring>>

- コードの不吉な臭い
- メソッドの構成
- オブジェクト間での特性の移動
- データの再編成
- 条件記述の単純化
- メソッド呼び出しの単純化
- 継承の取り扱い

==== リファクタリングの定義
==== リファクタリングを行う理由

- リファクタリングはソフトウェア設計を改善する
- リファクタリングはソフトウェアを理解しやすくする
- リファクタリングはバグを見つけ出す
- リファクタリングでより速くプログラミングできる
  ==== いつリファクタリングをすべきか
- ３度目の法則
- 機能追加時にリファクタリングを行う
- バグフィックスの時にリファクタリングを行う
- コードレビューの時にリファクタリングを行う

==== リファクタリングのヒント

- [ ] 構造的に機能を付け加えにくいプログラムに、新規機能を追加しなければならない場合には、まず機能追加が簡単になるようにリファクタリングをしてから追加を行うこと。

- [ ] リファクタリングに入る前に、しっかりとした一連のテスト群が用意できているかを確認すること。これらのテストには自己診断機能が不可欠である。

- [ ] リファクタリングでは小さなステップでプログラムを変更していく。そのため、誤ったことしても、バグを見つけるのは簡単である。

- [ ] コンパイラが理解出るコードは誰にでも書ける。すぐれたプログラマは、人間にとってわかりやすいコードを書く。

- [ ] リファクタリング（名詞）：外側から見たときの振る舞いを保ちつつ、理解や修正が簡単になるように、ソフトウェアの内部構造を変化させること。

- [ ] リファクタリングする（動詞）：一連のリファクタリングを適用して、外部から見た振る舞いの変更なしに、ソフトウェアを再構築すること。

- [ ] ３三度目になったらリファクタリング開始。

- [ ] あまり早期にインタフェースを公開しないこと。スムーズなリファクタリングのために、時にはコードの所有権のポリシーを変えることも必要。

- [ ] コメントの必要を感じたときにはリファクタリングを行って、コメントを書かなくとも内容がわかるようなコードを目指すこと。

- [ ] テストを完全に自動化して、その結果もテストにチェックさせること。

- [ ] テストをひとそろいにしておくと、バグの検出に絶大な威力を発揮する。これによって、バグの発見にかかる時間は削除される。

==== リファクタリングカタログ

===== メソッドの構成方法

- メソッドの抽出(Extract Method)
- メソッドのインライン化(Inline Method)
- 一時変数のインライン化(Inline Temp)
- 一時変数から問い合わせメソッドへ(Replace Temp with Query)
- 一時変数からチェインへ(Replace Temp with Query)
- 説明変数の導入(Introduce Explaining Variable)
- 一時変数の導入(Split Temporary Variable)
- 引数への代入の除去(Remove Assignments to Parameters)
- メソッドからメソッドオブジェクトへ(Replace Method with Method Object)
- アルゴリズム変更(Substitute Algorithm)
- ループからコレクションクロージャメソッドへ(Replace Loop with Collection Closure Method)
- サンドイッチメソッドの抽出(Extract Surrounding Method)
- クラスアノテーションの導入(Introduce Class Annotation)
- 名前付き引数の導入(Introduce Named Parameter)
- 名前付き引数の除去(Remove Named Parameter)
- 使われていないデフォルト引数の除去(Remove Unused Default Parameter)
- 動的メソッド定義(Dynamic Method Definition)
- 動的レセプタから動的メソッド定義へ(Replace Dynamic Receptor with Dynamic Method Definition)
- 動的レセプタの分離(Isolate Dynamic Receptor)
- eval を実行時からパース時へ(Move Eval from Runtime to Parse Time)

===== オブジェクト間でのメンバの移動

- メソッドの移動(Move Method)
- フィールドの移動(Move Field)
- クラスの抽出(Extract Class)
- クラスのインライン化(Inline Class)
- 移譲の隠蔽(Hide Delegate)
- 横流しブローカーの除去(Remove Middle Man)

===== データの構成

- 自己カプセル化フィールド(Self Encapsulate Field)
- データ値からオブジェクトへ(Replace Data Value with Object)
- 値から参照へ(Change Value to Reference)
- 参照から値へ(Change Reference to Value)
- 配列からオブジェクトへ(Replace Array with Object)
- ハッシュからオブジェクトへ(Replace Array with Object)
- 片方向リンクから双方向リンクへ(Change Unidirectional Association to Bidirectional)
- 双方向リンクから片方向リンクへ(Change Bidirectional Association to Unidirectional)
- マジックナンバーからシンボル定数へ(Replace Magic Number with Symbolic Constant)
- コレクションのカプセル化(Encapsulate Collection)
- レコードからデータクラスへ(Replace Record with Data Class)
- タイプコードからポリモーフィズムへ(Replace Type Code with Polymorphism)
- タイプコードからモジュールの extend へ(Replace Type Code with Module Extension)
- タイプコードから State/Strategy へ(Replace Type Code with State/Strategy)
- サブクラスからフィールドへ(Replace Subclass with Fields)
- 属性初期化の遅延実行(Lazily Initialized Attribute)
- 属性初期化の先行実行(Eagerly Initialized Attribute)

===== 条件式の単純化

- 条件分の分解(Decompose Conditional)
- 条件分岐の組み換え(Recompose Conditinal)
- 重複する条件分岐の断片の統合(Consolidate Duplicate Conditional Fragments)
- 制御フラグの除去
- 条件分岐のネストからガード節へ(Replace Nested Conditional with Guard Clauses)
- 条件分岐からポリモーフィズムへ(Replace Conditional with Polymorphism)
- null オブジェクトの導入(Introduce Null Object)
- アサーションの導入(Introduce Assertion)

===== メソッド呼び出しの単純化

- メソッド名の変更(Rename Method)
- 引数の追加(Add Parameter)
- 引数の削除(Remove Parameter)
- 問い合わせと更新の分離(Separate Query from Modifier)
- メソッドのパラメータ化(Parameterize Method)
- 引数から別々のメソッドへ(Replace Parameter with Explicit Methods)
- オブジェクト自体の受け渡し(Preserve Whole Object)
- 引数からメソッドへ(Replace Parameter with Method)
- 引数オブジェクトの導入(Introduce Parameter Object)
- 設定メソッドの削除(Remove Setting Method)
- メソッドの隠蔽(Hide Method)
- コンストラクタからファクトリメソッドへ(Replace Constructor with Factory Method)
- エラーコードから例外へ(Replace Error Code wiht Exception)
- 例外からテストへ(Replace Exception with Test)
- ゲートウェイの導入(Introduce Gateway)
- 式ビルダーの導入(Intorduce Expression Builder)

===== 一般化の処理

- メソッドの上位階層への移動(Pull Up Method)
- メソッドの下位階層への移動(Push Down Method)
- モジュールの抽出(Extract Module)
- モジュールのインライン化(Inline Module)
- サブクラスの抽出(Extract Subclass)
- 継承の導入(Introduce Inheritance)
- 階層構造の統合(Collapse Hierarchy)
- テンプレートメソッドの作成(From Template Method)
- 継承から移譲のへ(Replace Inheritance with Delegation)
- 委譲から継承へ(Replace Delegation with Hierarchy)
- 抽象スーパークラスからモジュールへ(Replae Abstract Superclass with Module)

===== 大規模なリファクタリング

- 複合的な継承階層の分割(Tease Apart Inheritance)
- 手続き型設計からオブジェクト指向設計へ(Convert Procedural Design to Objects)
- ドメインのプレゼンテーションからの分離(Separate Domain from Presentation)
- 継承階層の抽出(Extract Hierarchy)

==== においと経験則[^cc]
===== 設計の悪臭

1. 硬さ
1. もろさ
1. 移植性のなさ
1. 扱いにくさ
1. 不必要な複雑さ
1. 不必要な繰り返し
1. 不透明さ

===== コードの臭い

- コードの重複
- 長いメソッド
- 大きなクラス
- 長い引数リスト
- 変更系統の分岐
- ショットガン創の手術
- メソッドの浮気
- 群れたがるデータ
- プリミティブ強迫症
- case 文
- パラレルな継承階層
- 仕事をしないクラス
- 空論的一般化
- 一時フィールド
- メッセージの連鎖
- 横流しフローカー
- 親密すぎるクラス
- インターフェイスの異なるクラス群
- 不完全なライブラリクラス
- データクラス
- 継承した遺産の拒絶
- コメント
- メタプログラミング狂
- 柔軟すぎる API
- 紋切り型コードの繰り返し

- コメント
  ** C1:不適切な情報
  ** C2:退化コメント
  ** C3:冗長なコメント
  ** C4:記述不足のコメント
  ** C5:コメントアウトされたコード
- 環境
  ** E1:ビルドに複数のステップを要する
  ** E2:テストに複数のステップを要する
- 関数
  ** F1:多すぎる引数
  ** F2:出力引数
  ** F3:フラグ引数
  ** F4:死んだ関数
- 一般
  ** G1:１つのソースファイルに複数の言語を使用する
  ** G2:あって当然の振る舞いが実装されていない
  ** G3:境界値に対する不正確な振る舞い
  ** G4:安全軽視
  ** G5:重複
  ** G6:抽象レベルが正しくないコード
  ** G7:継承クラスに依存したベースクラス
  ** G8:情報過多
  ** G9:デッドコード
  ** G10:垂直分離
  ** G11:不整合
  ** G12:雑然
  ** G13:人為的な結合
  ** G14:機能の羨望
  ** G15:セレクタ引数
  ** G16:不明瞭な意図
  ** G17:責務を持たせる場所の間違い
  ** G18:不適切な static
  ** G19:説明的変数
  ** G20:関数名は体を表すべき
  ** G21:アルゴリズムを理解する
  ** G22:論理的な依存性を物理的なものとする
  ** G23:if/else や switch/case よりも多態を好む
  ** G24:標準や規約に従う
  ** G25:マジックナンバーを名前付けした定数に置き換える
  ** G26:正確であれ
  ** G27:規約より構造
  ** G28:条件をカプセル化せよ
  ** G29:条件の非定刑を避ける
  ** G30:関数では１つのことを行うべき
  ** G31:隠れた時間軸上の結合
  ** G32:いいかげんにならないこと
  ** G33:境界条件はカプセル化する
  ** G34:関数は１つの抽象レベルを担うべき
  ** G35:設定可能なデータは高いレベルに置く
  ** G36:推移的なナビゲーションを避ける
- Java
  ** J1:ワイルドカードを使って、長い import のリストを避ける
  ** J2:定数を継承しない
  ** J3:定数と enum
- 名前
  ** N1:記述的な名前を選ぶ
  ** N2:抽象レベルに適切な名前を選ぶ
  ** N3:可能な限り標準の用語を使用する
  ** N4:はっきりした名前
  ** N5:広いスコープには長い名前を
  ** N6:エンコーディングを避ける
  ** N7:名前で副作用を示すべき
- テスト
  ** T1:不十分なテスト
  ** T2:カバレッジツールを脂油する!
  ** T3:ささいなテストを省略しない
  ** T4:無視すること指定されたテストは、あいまいさへの問いかけである
  ** T5:境界条件テスト
  ** T6:バグの周辺は徹底的にテストを
  ** T7:失敗パターンは何かを語る
  ** T8:テストカバレッジのパターンは何かを語る
  ** T9:テストは高速に実行できるべき

=== 達人プログラマーチェックリスト

- [ ] 学ぶべき言語
- [ ] 合い言葉 WISDOM
      ** W 何(what)
      ** I 興味(interest)
      ** S 洗練(sophisticate)
      ** D 詳細(detail)
      ** O 誰の情報(own)
      ** M 動機づけ(motivate)
- [ ] 直交性
      ** 自己完結したコンポーネント、つまり独立し、単機能の、目的によく適合したコンポーネントを設計すること
      ** コードの結合度を最小化する
      ** グローバルデータを避ける
      ** 類似機能のリファクタリングを行う
- [ ] プロトタイプの適用対象
      ** アーキテクチャ
      ** 既存システムに追加する新機能
      ** サードパーティのツールやコンポーネント
      ** パフォーマンスの問題
      ** ユーザーインタフェースの設計
- [ ] アーキテクチャに関するチェックリスト
      ** 責任分担はうまく定義されているか？
      ** 協調関係はうまく定義されているか？
      ** 結合度は最小化されているか？
      ** 二重化の原因になりそうなものを識別できるか？
      ** インタフェース定義と制約は妥当なものか？
      ** モジュールが必要な時に必要なデータをアクセスできるか？
- [ ] デバッグ時のチェックリスト
      ** 報告を受けた問題は、元となるバグの直接的な結果でしょうか、それとも単なる症状なのでしょうか？
      ** 本当にコンパイラのバグでしょうか？OS のバグでしょうか？あなたのコードのバグなのでしょうか？
      ** この問題を同僚に説明するとしたら、どのように説明すればよいでしょか？
      ** 疑わしいコードが単体テストを終了していたのであれば、テストはちゃっと行われていたのでしょうか？このデータを使って単体テストを実行していたなら、どうなっていたのでしょうか？
      ** このバグを発生させた条件が、システム内のどこか他の部分に残っていないでしょうか？
- [ ] 機能に対するデメテルの法則
      ** 自分自身
      ** メソッドに引き渡されたパラメータ
      ** 自身が生成したオブジェクト
      ** 直接保持しているコンポーネントオブジェクト
- [ ] 慎重なプログラミングの方法
      ** 常に何をやっているのかを意識すること
      ** 目隠しでコーディングしないこと
      ** 明確なプランから進めるようにすること
      ** 信頼のおけるものを前提とすること
      ** 仮定をドキュメント化すること
      ** 単にコードをテストするのではなく、あなたの仮定をテストすること
      ** 作業に優先順位をつけること
      ** 過去のしがらみにとらわれないこと
- [ ] いつリファクタリングを行うべきか
      ** DRY 原則に反しているものを発見した場合
      ** より直交性の高いコードや設計ができる場合
      ** 知識が増えた場合
      ** 要求が変更された場合
      ** パフォーマンスを向上させる必要がある場合
- [ ] ゴルディアスの結び目を切る
      ** 簡単な手段は存在するのか？
      ** 正しい問題を解決しようとしているのか？
      ** なぜそれが問題なのか？
      ** 解決を難しくしている真の原因は何なのか？
      ** この手段でやり遂げなければならないのか？
      ** 多少なりともこの方法でやり遂げなければならないのか？
- [ ] 何をテストするか
      ** 単体テスト
      ** 統合テスト
      ** 妥当性確認および検証
      ** リソース消費、エラー、リカバリー
      ** パフォーマンステスト
      ** 利便性テスト
      ** テストのテスト

=== 練習<<CCD>>

武術もプログラミングも、スピードは練習の成果である。その練習はどちらもに似ている。問題と解決策からなる題目を選び、完全に習得するまで何度も実行するのだ。

==== 練習の背景

最初の練習用プログラム

```c
main()
{
  printf("hello, world\n")
}
```

==== コーディング道場

==== 型

プログラミングの型というのは、プログラミングの問題を解くためにキーボードやマウスの動きの練習である。実際に問題を解くわけではない。解き方はすでにわかっている。問題を解きながら体の動きや意思決定の練習をするのである。
ここでも完全に限りなく近づくことが目標となる。脳や指に動きや反応を覚えさせるために、何度も練習するのだ。練習するうちに、自分の動きや解決策が少しづつ改善・効率化されることに気づくだろう。
型を使った練習は、ホットキーや操作のイデオムの学習に適している。TDD や CI（継続的インテグレーション）などの規律の学習にも優れた方法である。そして、最も重要なのは、よくある問題と解決策の組み合わせを潜在意識に植えつけることで、現実のプログラミングの問題解決方法がわかるようになるということだ。
武術家のようにプログラマは複数の型を知り、定期的に練習することで、記憶に残るようになる。型の多くは、http://katas.softwarecraftsmanship.org にある。

- http://butunclebob.com/ArticleS.UncleBob.TheBowlingGameKata[ボウリングゲーム]
- http://butunclebob.com/ArticleS.UncleBob.ThePrimeFactorsKata[素因数分解]
- http://thecleancoder.blogspot.jp/2010/10/craftsman-62-dark-path.html[ワードラップ]

==== 技

プログラマもこれと同じ練習ができる。 http://c2.com/cgi/wiki?PairProgrammingPingPongPattern[ピンポンゲーム] を使うのだ。まず、２人で型または簡単な問題を選ぶ。次に、１人がユニットテストを書き、もう１人がテストを成功させる。そして、役割を交代する。

==== 乱取り

２人組でパートナーが問題を解く「技」とよく似ているが、こちらは参加人数が多く、ルールも少し変更されている。まず、プロジェクタに画面を写す。次に、１人がテストを書く。そして、次の人がテストを成功させて、次のテストを書く。これを順番にやっていくのだ。
ここから学べることはすごく多い。他の人が問題を解く様子がよくわかるからだ。それによって、自分のやり方を改善し、スキルを向上させられる。

==== エチュード<<WEB01>>

===== ピアノ

===== エチュードは技術習得の近道

エチュードとは、練習曲のこと。
エチュードは必ず何らかの技術習得を目的として作曲されている。繰り返し練習することで、その技術を効率的に身につけられるようになっている。
自分の引きたい曲があって、その曲だけを一生懸命にピアノで練習するより、その曲を弾きこなすのに必要な技術をエチュードで身につけてから練習したほうが短期間で弾くことができるよになる。

===== 初級のエチュード

「バイエル」、「ハノン」、「みんなのオルガン・ピアノの本」、「ブルグミュラー」、「ピアノエチュード集」などのエチュードはピアノを弾くための基本的な技術を習得することができる。

楽譜に書かれている情報を正しく認識できるようになることが初級の段階で学ぶべきこと

===== 中級のエチュードとは

「ソナチネ」、「チェルニー」、「ピアニストの毎日の基礎練習帳」などがある。

中級では表面上に書かれている音符から、作曲者の意図を読み取る力を養う段階に入る。
言いかえれば、ピアノを通して音楽的な表現をどのようにしていくのかということを考え始める段階ということ。

===== チェス

===== エンドゲーム・スタディ<<WEB03>>

> エンドゲームスタディあるいは単にスタディとは、一種の問題として提示される作り物の（つまり実戦から取られたのではなく創作された）チェスの局面で、一方（通常白）が他方のいかなる指し手に対しても勝つ（または引き分ける）手順を解答として求めるものを言う。なお、エンドゲームスタディはエチュードと呼ばれることもある。

===== 将棋

====== 定跡

> 定石、定跡（じょうせき）とは、アブストラクトゲームにおける用語である。お互いが最善と考えられる手を行った場合の一連の手のこと。チェスでは、「オープニング」とも。石を用いる囲碁、オセロ、連珠などでは「定石」が、駒を用いる将棋、チェスなどでは「定跡」が用いられる。

> 一般的には序盤が定跡化されており、指し手の選択によって、先手有利、後手有利などの変化が生じる。戦法によっては、終盤まで定跡化されていることもある。これらは日々専門家の実戦によって変化している。

> チェスの序盤における定跡は特にオープニングと呼ばれ、シシリアン・ディフェンスなど固有名の他、ECO コードと呼ばれる分類記号も使われる。将棋でも洗練され、多く用いられるようになると山田定跡、木村定跡、鷺宮定跡などのように名前が付けられる。

> チェスの場合は終盤に向けて駒が少なくなっていくため、終盤についても常形の局面が研究されており、これも定跡ということができる。特に残り駒数が両キングを含めて 7 以下の局面については、コンピュータ解析によってすべて最善の手順が求められ、データベース化されている。

https://ja.wikipedia.org/wiki/%E5%AE%9A%E7%9F%B3[定石]

https://www.shogi.or.jp/column/2016/12/3_1.html[この3つを学べば、初心者卒業！序盤を学ぶために、必ず知っておくべきこととは？]

====== 手筋

> 手筋（てすじ）とは囲碁用語の一つで、通常より大きな効果を挙げることのできる着手のことである。多くの場合、平凡な発想では達し得ない、やや意外性を含んだ効果的な手を指すことが多い。単に「筋」（すじ）と呼ぶこともある。将棋やチェスなどにおいても同様の意味で使われる。

http://www.shogi-rule.com/category10/entry53.html[将棋の手筋を掴む]

===== 写経<<WEB02>>

> 写経は、印刷技術が発展していなかった時代には仏法を広めるため、またはひとつの寺院でも複数の僧侶で修行・講義・研究するために必要なことであった。その後 、写経することに功徳があることが説かれるようになった

1.  ローカルで使える SCM を用意
1.  「ほんたった」などで対象の本を固定
1.  ひたすらサンプルコードを写して実行
1.  実行するたびにコミット(コミットログにページ番号を含める)
1.  疑問点があったらコミットログや本に書き込む
1.  章ごとにタグを打つ

==== プログラマの毎日の基礎練習プログラム

===== 初級のエチュード

- 指の動かし方
  ** エディタ
- ドキュメントの書き方
  ** Markdown
- 環境の構築方法
  ** 仮想マシン
  ** バージョン管理
  ** パッケージ管理
- アプリケーション開発ライフサイクル
  ** GitHubFlow
  ** GitFlow
- プログラミング３大要素
  ** 原則
  ** パターン
  ** プラクティス

===== 中級のエチュード

- 原則
- パターン
- プラクティス

== 参照

=== 参考図書

=== 参考リンク

- http://docs.komagata.org/5541[なぜプログラミングは楽しいのか？]

[bibliography]
=== Reference

- [[[UNIXP]]]: UNIX という考え方 2001
- [[[PPP02]]]: Agile Software Development: Principles, Patters, and Practices, 2002
- [[[CC]]]: Clean Code 2090
- [[[CA]]]: Clean Architecture 2018
- [[[CCD]]]: Clean Coder
- [[[PoEAA]]]: Patterns of Enterprise Application Architecture
- [[[GOF]]]: Elements of Reusable Object Oriented Software 1996
- [[[Refactoring]]]: リファクタリングープログラムの体質改善テクニック 1999
- [[[PoSA]]]: 現場で役立つシステム設計の原則 2017
- [[[IP]]]: 実装パターン
- [[[WEB01]]]: http://piano-practice.click/practice/etude-2/[エチュードを練習する重要性│ピアノの上達法]
- [[[WEB02]]]: https://twitter.com/t_wada/status/9000231741
- [[[WEB03]]]: https://ja.wikipedia.org/wiki/%E3%82%A8%E3%83%B3%E3%83%89%E3%82%B2%E3%83%BC%E3%83%A0%E3%83%BB%E3%82%B9%E3%82%BF%E3%83%87%E3%82%A3
